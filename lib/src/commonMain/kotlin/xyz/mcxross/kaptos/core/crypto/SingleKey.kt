/*
 * Copyright 2025 McXross
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package xyz.mcxross.kaptos.core.crypto

import xyz.mcxross.kaptos.core.AuthenticationKey
import xyz.mcxross.kaptos.model.*

/**
 * Represents any public key supported by Aptos.
 *
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports `Legacy` and
 * `Unified` authentication keys.
 *
 * Any unified authentication key is represented in the SDK as `AnyPublicKey`.
 */
class AnyPublicKey(val publicKey: PublicKey) : AccountPublicKey() {

  val variant: AnyPublicKeyVariant
    get() =
      when (publicKey) {
        is Ed25519PublicKey -> AnyPublicKeyVariant.Ed25519
        is Secp256k1PublicKey -> AnyPublicKeyVariant.Secp256k1
        else -> throw IllegalArgumentException("Unsupported public key type")
      }

  override fun authKey(): AuthenticationKey {
    return AuthenticationKey.fromSchemeAndBytes(
      AuthenticationKeyScheme.Signing(SigningScheme.SingleKey),
      HexInput.fromByteArray(toBcs()),
    )
  }

  override fun verifySignature(message: HexInput, signature: Signature): Boolean {
    val actualSignature = if (signature is AnySignature) signature.signature else signature
    return publicKey.verifySignature(message, actualSignature)
  }

  override fun toByteArray(): ByteArray = toBcs()

  override fun toBcs(): ByteArray {
    val variantIndex =
      when (variant) {
        AnyPublicKeyVariant.Ed25519 -> 0
        AnyPublicKeyVariant.Secp256k1 -> 1
      }
    return encodeUleb128(variantIndex) + publicKey.toBcs()
  }
}

/**
 * Instance of signature that uses the SingleKey authentication scheme. This signature can only be
 * generated by a `SingleKeySigner`, since it uses the same authentication scheme.
 */
class AnySignature(val signature: Signature) : Signature() {

  var variant: AnySignatureVariant =
    when (signature) {
      is Ed25519Signature -> AnySignatureVariant.Ed25519
      is Secp256k1Signature -> AnySignatureVariant.Secp256k1
      else -> throw IllegalArgumentException("Unsupported signature type")
    }

  override fun toByteArray(): ByteArray = toBcs()

  override fun toBcs(): ByteArray {
    return encodeUleb128(variant.value) + signature.toBcs()
  }
}
